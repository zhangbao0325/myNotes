# [智能指针](https://rust.bootcss.com/ch15-00-smart-pointers.html#智能指针)

**指针** （*pointer*）是一个包含内存地址的变量的通用概念。这个地址引用，或 “指向”（points at）一些其他数据。Rust 中最常见的指针是之前介绍的 **引用**（*reference*）。引用以 `&` 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用的最多。

另一方面，**智能指针**（*smart pointers*）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。智能指针的概念并不为 Rust 所独有；其起源于 C++ 并存在于其他语言中。Rust 标准库中不同的智能指针提供了多于引用的额外功能。本章将会探索的一个例子便是 **引用计数** （*reference counting*）智能指针类型，其允许数据有多个所有者。引用计数智能指针记录总共有多少个所有者，并当没有任何所有者时负责清理数据。

**<font color=#FF0000 > 在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针 拥有 他们指向的数据。</font>**

实际上之前已经出现过一些智能指针，比如 `String` 和 `Vec<T>`，虽然当时我们并不这么称呼它们。这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们。它们也带有元数据（比如他们的容量）和额外的功能或保证（`String` 的数据总是有效的 UTF-8 编码）。

**<font color=#FF0000 >智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了 `Deref` 和 `Drop` trait。`Deref` trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码。`Drop` trait 允许我们自定义当智能指针离开作用域时运行的代码。</font>**这些 trait对智能指针来说很重要。

考虑到智能指针是一个在 Rust 经常被使用的通用设计模式，本章并不会覆盖所有现存的智能指针。很多库都有自己的智能指针而你也可以编写属于你自己的智能指针。这里将会讲到的是来自标准库中最常用的一些：

- `Box<T>`，用于在堆上分配值
- `Rc<T>`，一个引用计数类型，其数据可以有多个所有者
- `Ref<T>` 和 `RefMut<T>`，通过 `RefCell<T>` 访问，一个在**运行时**而不是在**编译时**执行借用规则的类型。

另外我们会涉及 **内部可变性**（*interior mutability*）模式，这时不可变类型暴露出改变其内部值的 API。我们也会讨论 **引用循环**（*reference cycles*）会如何泄露内存，以及如何避免。

# Box\<T>

最简单直接的智能指针是 *box*，其类型是 `Box<T>`。 box 允许你将一个值放在堆上而不是栈上

除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用于如下场景：

- 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
- 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
- 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候

我们会在 “box 允许创建递归类型” 部分展示第一种场景。在第二种情况中，转移大量数据的所有权可能会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 box 将这些数据储存在堆上。接着，只有少量的指针数据在栈上被拷贝。第三种情况被称为 **trait 对象**（*trait object*），为使用不同类型的值而设计的 trait 对象。

### 使用 `Box` 在堆上储存数据

在讨论 `Box<T>` 的用例之前，让我们熟悉一下语法以及如何与储存在 `Box<T>` 中的值进行交互。

示例 展示了如何使用 box 在堆上储存一个 `i32`：

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

这里定义了变量 `b`，其值是一个指向被分配在堆上的值 `5` 的 `Box`。这个程序会打印出 `b = 5`；在这个例子中，我们可以像数据是储存在栈上的那样访问 box 中的数据。正如任何拥有数据所有权的值那样，当像 `b` 这样的 box 在 `main` 的末尾离开作用域时，它将被释放。**这个释放过程作用于 box 本身（位于栈上）和它所指向的数据（位于堆上）**。

将一个单独的值存放在堆上并不是很有意义，所以像示例这样单独使用 box 并不常见。将像单个 `i32` 这样的值储存在栈上，也就是其默认存放的地方在大部分使用场景中更为合适。让我们看看一个不使用 box 时无法定义的类型的例子。

### [Box 允许创建递归类型](https://rust.bootcss.com/ch15-01-box.html#box-允许创建递归类型)

Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 **递归类型**（*recursive type*），其值的一部分可以是相同类型的另一个值。这种值的嵌套理论上可以无限的进行下去，所以 Rust 不知道递归类型需要多少空间。不过 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了。

让我们探索一下 *cons list*，一个函数式编程语言中的常见类型，来展示这个（递归类型）概念。除了递归之外，我们将要定义的 cons list 类型是很直白的，所以这个例子中的概念，在任何遇到更为复杂的涉及到递归类型的场景时都很实用。

#### [cons list 的更多内容](https://rust.bootcss.com/ch15-01-box.html#cons-list-的更多内容)

*cons list* 是一个来源于 Lisp 编程语言及其方言的数据结构。在 Lisp 中，`cons` 函数（“construct function" 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表。

cons 函数的概念涉及到更常见的函数式编程术语；“将 *x* 与 *y* 连接” 通常意味着构建一个新的容器而将 *x* 的元素放在新容器的开头，其后则是容器 *y* 的元素。

cons list 的每一项都包含两个元素：当前项的值和下一项。其最后一项值包含一个叫做 `Nil` 的值且没有下一项。cons list 通过递归调用 `cons` 函数产生。代表递归的终止条件（base case）的规范名称是 `Nil`，它宣布列表的终止。注意这不同于 “null” 或 “nil” 的概念，他们代表无效或缺失的值。

注意虽然函数式编程语言经常使用 cons list，但是它并不是一个 Rust 中常见的类型。大部分在 Rust 中需要列表的时候，`Vec<T>` 是一个更好的选择。其他更为复杂的递归数据类型 **确实** 在 Rust 的很多场景中很有用，不过通过以 cons list 作为开始，我们可以探索如何使用 box 毫不费力的定义一个递归数据类型。

示例2包含一个 cons list 的枚举定义。注意这还不能编译因为这个类型没有已知的大小，之后我们会展示：

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

示例 2：第一次尝试定义一个代表 `i32` 值的 cons list 数据结构的枚举

使用这个 cons list 来储存列表 `1, 2, 3` 将看起来如示例3 所示：

```rust
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

示例 3：使用 `List` 枚举储存列表 `1, 2, 3`

第一个 `Cons` 储存了 `1` 和另一个 `List` 值。这个 `List` 是另一个包含 `2` 的 `Cons` 值和下一个 `List` 值。接着又有另一个存放了 `3` 的 `Cons` 值和最后一个值为 `Nil` 的 `List`，非递归成员代表了列表的结尾。

如果尝试编译示例 3 的代码，会得到如下的错误：

```text
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable
```

尝试定义一个递归枚举时得到的错误，这个错误表明这个类型 “有无限的大小”。其原因是 `List` 的一个成员被定义为是递归的：它直接存放了另一个相同类型的值。这意味着 Rust 无法计算为了存放 `List` 值到底需要多少空间。让我们一点一点来看：首先了解一下 Rust 如何决定需要多少空间来存放一个非递归类型。

### [计算非递归类型的大小](https://rust.bootcss.com/ch15-01-box.html#计算非递归类型的大小)

例如定义的 `Message` 枚举：

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

当 Rust 需要知道要为 `Message` 值分配多少空间时，它可以检查每一个成员并发现 `Message::Quit` 并不需要任何空间，`Message::Move` 需要足够储存两个 `i32` 值的空间，依此类推。因此，`Message` 值所需的空间等于储存其最大成员的空间大小。

与此相对当 Rust 编译器检查像示例2 中的 `List` 这样的递归类型时会发生什么呢。编译器尝试计算出储存一个 `List` 枚举需要多少内存，并开始检查 `Cons` 成员，那么 `Cons` 需要的空间等于 `i32` 的大小加上 `List` 的大小。为了计算 `List` 需要多少内存，它检查其成员，从 `Cons` 成员开始。`Cons`成员储存了一个 `i32` 值和一个`List`值，这样的计算将无限进行下去，如图 1 所示：

![An infinite Cons list](https://rust.bootcss.com/img/trpl15-01.svg)图 1：一个包含无限个 `Cons` 成员的无限 `List`

### 使用 `Box` 给递归类型一个已知的大小

Rust 无法计算出要为定义为递归的类型分配多少空间，所以编译器给出了示例4 中的错误。这个错误也包括了有用的建议：

```text
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable
```

在建议中，“indirection” 意味着不同于直接储存一个值，我们将间接的储存一个指向值的指针。

因为 `Box<T>` 是一个指针，我们总是知道它需要多少空间：指针的大小并不会根据其指向的数据量而改变。这意味着可以将 `Box` 放入 `Cons` 成员中而不是直接存放另一个 `List` 值。`Box` 会指向另一个位于堆上的 `List` 值，而不是存放在 `Cons` 成员中。从概念上讲，我们仍然有一个通过在其中 “存放” 其他列表创建的列表，不过现在实现这个概念的方式更像是一个项挨着另一项，而不是一项包含另一项。

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
```

示例5为了拥有已知大小而使用 `Box<T>` 的 `List` 定义

`Cons` 成员将会需要一个 `i32` 的大小加上储存 box 指针数据的空间。`Nil` 成员不储存值，所以它比 `Cons` 成员需要更少的空间。现在我们知道了任何 `List` 值最多需要一个 `i32` 加上 box 指针数据的大小。通过使用 box ，打破了这无限递归的连锁，这样编译器就能够计算出储存 `List` 值需要的大小了。图 15-2 展示了现在 `Cons` 成员看起来像什么：

![A finite Cons list](https://rust.bootcss.com/img/trpl15-02.svg)

图 2：因为 `Cons` 存放一个 `Box` 所以 `List` 不是无限大小的了

box 只提供了间接存储和堆分配；他们并没有任何其他特殊的功能，比如我们将会见到的其他智能指针。它们也没有这些特殊功能带来的性能损失，所以他们可以用于像 cons list 这样间接存储是唯一所需功能的场景。box 的更多应用场景后面再介绍。

`Box<T>` 类型是一个智能指针，因为它实现了 `Deref` trait，它允许 `Box<T>` 值被当作引用对待。当 `Box<T>` 值离开作用域时，由于 `Box<T>` 类型 `Drop` trait 的实现，box 所指向的堆数据也会被清除。

# Rc

大部分情况下所有权是非常明确的：可以准确地知道哪个变量拥有某个值。然而，有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的结点，而这个结点从概念上讲为所有指向它的边所拥有。结点直到没有任何边指向它之前都不应该被清理。

<font color=#FF0000>**为了启用多所有权，Rust 有一个叫做 `Rc<T>` 的类型。其名称为 **引用计数**（*reference counting*）的缩写。引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。</font>

`Rc<T>` 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。

注意 `Rc<T>` 只能用于单线程场景；

### 使用 `Rc` 共享数据

让我们回到示例5 中使用 `Box<T>` 定义 cons list 的例子。这一次，我们希望创建两个共享第三个列表所有权的列表，其概念将会看起来如图 15-3 所示：

![Two lists that share ownership of a third list](https://rust.bootcss.com/img/trpl15-03.svg)

图 3: 两个列表, `b` 和 `c`, 共享第三个列表 `a` 的所有权

列表 `a` 包含 5 之后是 10，之后是另两个列表：`b` 从 3 开始而 `c` 从 4 开始。`b` 和 `c` 会接上包含 5 和 10 的列表 `a`。换句话说，这两个列表会尝试共享第一个列表所包含的 5 和 10。

尝试使用 `Box<T>` 定义的 `List` 并实现不能工作，如示例 15-17 所示：

文件名: src/main.rs

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

示例展示不能用两个 `Box<T>` 的列表尝试共享第三个列表的所有权

编译会得出如下错误：

```text
error[E0382]: use of moved value: `a`
  --> src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
```

`Cons` 成员拥有其储存的数据，所以当创建 `b` 列表时，`a` 被移动进了 `b` 这样 `b` 就拥有了 `a`。接着当再次尝使用 `a` 创建 `c` 时，这不被允许因为 `a` 的所有权已经被移动。

可以改变 `Cons` 的定义来存放一个引用，不过接着必须指定生命周期参数。通过指定生命周期参数，表明列表中的每一个元素都至少与列表本身存在的一样久。例如，借用检查器不会允许 `let a = Cons(10, &Nil);` 编译，因为临时值 `Nil` 会在 `a` 获取其引用之前就被丢弃了。

相反，我们修改 `List` 的定义为使用 `Rc<T>` 代替 `Box<T>`。 每一个 `Cons` 变量都包含一个值和一个指向 `List` 的 `Rc`。当创建 `b` 时，不同于获取 `a` 的所有权，这里会克隆 `a` 所包含的 `Rc`，这会将引用计数从 1 增加到 2 并允许 `a` 和 `b` 共享 `Rc` 中数据的所有权。创建 `c` 时也会克隆 `a`，这会将引用计数从 2 增加为 3。每次调用 `Rc::clone`，`Rc` 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

示例 : 使用 `Rc<T>` 定义的 `List`

需要使用 `use` 语句将 `Rc<T>` 引入作用域，因为它不在 prelude 中。在 `main` 中创建了存放 5 和 10 的列表并将其存放在 `a` 的新的 `Rc<List>` 中。接着当创建 `b` 和 `c` 时，调用 `Rc::clone` 函数并传递 `a` 中 `Rc<List>` 的引用作为参数。

注意：a.clone 和 Rc::clone的区别。

也可以调用 `a.clone()` 而不是 `Rc::clone(&a)`，不过在这里 Rust 的习惯是使用 `Rc::clone`。`Rc::clone` 的实现并不像大部分类型的 `clone` 实现那样对所有数据进行深拷贝。`Rc::clone` 只会增加引用计数，这并不会花费多少时间。深拷贝可能会花费很长时间。通过使用 `Rc::clone` 进行引用计数，可以明显的区别深拷贝类的克隆和增加引用计数类的克隆。当查找代码中的性能问题时，只需考虑深拷贝类的克隆而无需考虑 `Rc::clone` 调用。

### 克隆 `Rc` 会增加引用计数

让我们修改示上述代码以便观察创建和丢弃 `a` 中 `Rc<List>` 的引用时引用计数的变化。

在示例 15-19 中，修改了 `main` 以便将列表 `c` 置于内部作用域中，这样就可以观察当 `c` 离开作用域时引用计数如何变化。

```rust
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 `Rc::strong_count` 函数获得。这个函数叫做 `strong_count` 而不是 `count` 是因为 `Rc<T>` 也有 `weak_count`；在 [“避免引用循环：将 `Rc` 变为 `Weak`”](https://rust.bootcss.com/preventing-ref-cycles) 部分会讲解 `weak_count` 的用途。

这段代码会打印出：

```text
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

我们能够看到 `a` 中 `Rc<List>` 的初始引用计数为1，接着每次调用 `clone`，计数会增加1。当 `c` 离开作用域时，计数减1。不必像调用 `Rc::clone` 增加引用计数那样调用一个函数来减少计数；`Drop` trait 的实现当 `Rc<T>` 值离开作用域时自动减少引用计数。

从这个例子我们所不能看到的是，在 `main` 的结尾当 `b` 然后是 `a` 离开作用域时，此处计数会是 0，同时 `Rc` 被完全清理。使用 `Rc` 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。

**通过不可变引用， `Rc<T>` 允许在程序的多个部分之间只读地共享数据。如果 `Rc<T>` 也允许多个可变引用，则会违反借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致。不过可以修改数据是非常有用的！**在下一部分，我们将讨论内部可变性模式和 `RefCell<T>` 类型，它可以与 `Rc<T>` 结合使用来处理不可变性的限制。



## `RefCell` 和内部可变性模式

**内部可变性**（*Interior mutability*）是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的。为了改变数据，该模式在数据结构中使用 `unsafe` 代码来模糊 Rust 通常的可变性和借用规则。当可以确保代码在运行时会遵守借用规则，即使编译器不能保证的情况，可以选择使用那些运用内部可变性模式的类型。所涉及的 `unsafe` 代码将被封装进安全的 API 中，而外部类型仍然是不可变的。

让我们通过遵循内部可变性模式的 `RefCell<T>` 类型来开始探索。

### 通过 `RefCell` 在运行时检查借用规则

不同于 `Rc<T>`，`RefCell<T>` 代表其数据的唯一的所有权。那么是什么让 `RefCell<T>` 不同于像 `Box<T>` 这样的类型呢？借用规则：

1. 在任意给定时间，只能拥有一个可变引用或任意数量的不可变引用 **之一**（而不是全部）。
2. 引用必须总是有效的。

对于引用和 `Box<T>`，借用规则的不可变性作用于编译时。对于 `RefCell<T>`，这些不可变性作用于 **运行时**。对于引用，如果违反这些规则，会得到一个编译错误。而对于 `RefCell<T>`，如果违反这些规则程序会 panic 并退出。

在编译时检查借用规则的优势是这些错误将在开发过程的早期被捕获，同时对运行时没有性能影响，因为所有的分析都提前完成了。为此，在编译时检查借用规则是大部分情况的最佳选择，这也正是其为何是 Rust 的默认行为。

相反在运行时检查借用规则的好处则是允许出现特定内存安全的场景，而它们在编译时检查中是不允许的。静态分析，正如 Rust 编译器，是天生保守的。但代码的一些属性不可能通过分析代码发现。

因为一些分析是不可能的，如果 Rust 编译器不能通过所有权规则编译，它可能会拒绝一个正确的程序；从这种角度考虑它是保守的。如果 Rust 接受不正确的程序，那么用户也就不会相信 Rust 所做的保证了。然而，如果 Rust 拒绝正确的程序，虽然会给程序员带来不便，但不会带来灾难。`RefCell<T>` 正是用于当你确信代码遵守借用规则，而编译器不能理解和确定的时候。

类似于 `Rc<T>`，`RefCell<T>` 只能用于单线程场景。如果尝试在多线程上下文中使用`RefCell<T>`，会得到一个编译错误。

如下为选择 `Box<T>`，`Rc<T>` 或 `RefCell<T>` 的理由：

- `Rc<T>` 允许相同数据有多个所有者；`Box<T>` 和 `RefCell<T>` 有单一所有者。
- `Box<T>` 允许在编译时执行不可变或可变借用检查；`Rc<T>`仅允许在编译时执行不可变借用检查；`RefCell<T>` 允许在运行时执行不可变或可变借用检查。
- 因为 `RefCell<T>` 允许在运行时执行可变借用检查，所以我们可以在即便 `RefCell<T>` 自身是不可变的情况下修改其内部的值。

在不可变值内部改变值就是 **内部可变性** 模式。让我们看看何时内部可变性是有用的，并讨论这是如何成为可能的。

### [内部可变性：不可变值的可变借用](https://rust.bootcss.com/ch15-05-interior-mutability.html#内部可变性不可变值的可变借用)

借用规则的一个推论是当有一个不可变值时，不能可变地借用它。例如，如下代码不能编译：

```rust
fn main() {
    let x = 5;
    let y = &mut x;
}
```

如果尝试编译，会得到如下错误：

```text
error[E0596]: cannot borrow immutable local variable `x` as mutable
 --> src/main.rs:3:18
  |
2 |     let x = 5;
  |         - consider changing this to `mut x`
3 |     let y = &mut x;
  |                  ^ cannot borrow mutably
```

然而，特定情况下在值的方法内部能够修改自身是很有用的，而不是在其他代码中。此时值仍然是不可变的，值方法外部的代码不能修改其值。`RefCell<T>` 是一个获得内部可变性的方法。`RefCell<T>` 并没有完全绕开借用规则，编译器中的借用检查器允许内部可变性并相应地在运行时检查借用规则。如果违反了这些规则，会得到 `panic!` 而不是编译错误。

让我们通过一个实际的例子来探索何处可以使用 `RefCell<T>` 来修改不可变值并看看为何这么做是有意义的。

#### [内部可变性的用例：mock 对象](https://rust.bootcss.com/ch15-05-interior-mutability.html#内部可变性的用例mock-对象)

**测试替身**（*test double*）是一个通用编程概念，它代表一个在测试中替代某个类型的类型。**mock 对象** 是特定类型的测试替身，它们记录测试过程中发生了什么以便可以断言操作是正确的。

虽然 Rust 没有与其他语言中的对象完全相同的对象，Rust 也没有像其他语言那样在标准库中内建 mock 对象功能，不过我们确实可以创建一个与 mock 对象有着相同功能的结构体。

如下是一个我们想要测试的场景：我们在编写一个记录某个值与最大值的差距的库，并根据当前值与最大值的差距来发送消息。例如，这个库可以用于记录用户所允许的 API 调用数量限额。

该库只提供记录与最大值的差距，以及何种情况发送什么消息的功能。使用此库的程序则期望提供实际发送消息的机制：程序可以选择记录一条消息、发送 email、发送短信等等。库本身无需知道这些细节；只需实现其提供的 `Messenger` trait 即可。示例展示了库代码：

文件名: src/lib.rs

```rust
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
    where T: Messenger {
    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
             self.messenger.send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger.send("Warning: You've used up over 75% of your quota!");
        }
    }
}
```

示例一个记录某个值与最大值差距的库，并根据此值的特定级别发出警告

这些代码中一个重要部分是拥有一个方法 `send` 的 `Messenger` trait，其获取一个 `self` 的不可变引用和文本信息。这是我们的 mock 对象所需要拥有的接口。另一个重要的部分是我们需要测试 `LimitTracker` 的 `set_value` 方法的行为。可以改变传递的 `value` 参数的值，不过 `set_value` 并没有返回任何可供断言的值。也就是说，如果使用某个实现了 `Messenger` trait 的值和特定的 `max` 创建 `LimitTracker`，当传递不同 `value` 值时，消息发送者应被告知发送合适的消息。

我们所需的 mock 对象是，调用 `send` 不同于实际发送 email 或短息，其只记录信息被通知要发送了。可以新建一个 mock 对象示例，用其创建 `LimitTracker`，调用 `LimitTracker` 的 `set_value` 方法，然后检查 mock 对象是否有我们期望的消息。示例 15-21 展示了一个如此尝试的 mock 对象实现，不过借用检查器并不允许：

文件名: src/lib.rs

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
```

示例 15-21：尝试实现 `MockMessenger`，借用检查器不允许这么做

测试代码定义了一个 `MockMessenger` 结构体，其 `sent_messages` 字段为一个 `String` 值的 `Vec` 用来记录被告知发送的消息。我们还定义了一个关联函数 `new` 以便于新建从空消息列表开始的 `MockMessenger` 值。接着为 `MockMessenger` 实现 `Messenger` trait 这样就可以为 `LimitTracker` 提供一个 `MockMessenger`。在 `send` 方法的定义中，获取传入的消息作为参数并储存在 `MockMessenger` 的 `sent_messages` 列表中。

在测试中，我们测试了当 `LimitTracker` 被告知将 `value` 设置为超过 `max` 值 75% 的某个值。首先新建一个 `MockMessenger`，其从空消息列表开始。接着新建一个 `LimitTracker` 并传递新建 `MockMessenger` 的引用和 `max` 值 100。我们使用值 80 调用 `LimitTracker` 的 `set_value` 方法，这超过了 100 的 75%。接着断言 `MockMessenger` 中记录的消息列表应该有一条消息。

然而，这个测试是有问题的：

```text
error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable
  --> src/lib.rs:52:13
   |
51 |         fn send(&self, message: &str) {
   |                 ----- use `&mut self` here to make mutable
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field
```

不能修改 `MockMessenger` 来记录消息，因为 `send` 方法获取了 `self` 的不可变引用。我们也不能参考错误文本的建议使用 `&mut self` 替代，因为这样 `send` 的签名就不符合 `Messenger` trait 定义中的签名了（可以试着这么改，看看会出现什么错误信息）。

这正是内部可变性的用武之地！我们将通过 `RefCell` 来储存 `sent_messages`，然后 `send` 将能够修改 `sent_messages` 并储存消息。示例 15-22 展示了代码：

文件名: src/lib.rs

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
```

示例 ：使用 `RefCell<T>` 能够在外部值被认为是不可变的情况下修改内部值

现在 `sent_messages` 字段的类型是 `RefCell<Vec<String>>` 而不是 `Vec<String>`。在 `new` 函数中新建了一个 `RefCell` 示例替代空 vector。

对于 `send` 方法的实现，第一个参数仍为 `self` 的不可变借用，这是符合方法定义的。我们调用 `self.sent_messages` 中 `RefCell` 的 `borrow_mut` 方法来获取 `RefCell` 中值的可变引用，这是一个 vector。接着可以对 vector 的可变引用调用 `push` 以便记录测试过程中看到的消息。

最后必须做出的修改位于断言中：为了看到其内部 vector 中有多少个项，需要调用 `RefCell` 的 `borrow` 以获取 vector 的不可变引用。

现在我们见识了如何使用 `RefCell<T>`，让我们研究一下它怎样工作的！

### [`RefCell` 在运行时记录借用](https://rust.bootcss.com/ch15-05-interior-mutability.html#refcellt-在运行时记录借用)

当创建不可变和可变引用时，我们分别使用 `&` 和 `&mut` 语法。对于 `RefCell<T>` 来说，则是 `borrow` 和 `borrow_mut` 方法，这属于 `RefCell<T>` 安全 API 的一部分。`borrow` 方法返回 `Ref` 类型的智能指针，`borrow_mut` 方法返回 `RefMut` 类型的智能指针。这两个类型都实现了 `Deref`，所以可以当作常规引用对待。

`RefCell<T>` 记录当前有多少个活动的 `Ref<T>` 和 `RefMut<T>` 智能指针。每次调用 `borrow`，`RefCell<T>` 将活动的不可变借用计数加一。当 `Ref` 值离开作用域时，不可变借用计数减一。就像编译时借用规则一样，`RefCell<T>` 在任何时候只允许有多个不可变借用或一个可变借用。

如果我们尝试违反这些规则，相比引用时的编译时错误，`RefCell<T>` 的实现会在运行时 `panic!`。下面示例展示了对示例中 `send` 实现的修改，这里我们故意尝试在相同作用域创建两个可变借用以便演示 `RefCell<T>` 不允许我们在运行时这么做：

文件名: src/lib.rs

```rust
impl Messenger for MockMessenger {
    fn send(&self, message: &str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
```

示例：在同一作用域中创建两个可变引用并观察 `RefCell<T>` panic

这里为 `borrow_mut` 返回的 `RefMut` 智能指针创建了 `one_borrow` 变量。接着用相同的方式在变量 `two_borrow` 创建了另一个可变借用。这会在相同作用域中创建两个可变引用，这是不允许的。当运行库的测试时，上面示例编译时不会有任何错误，不过测试会失败：

```text
---- tests::it_sends_an_over_75_percent_warning_message stdout ----
	thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at
'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

注意代码 panic 和信息 `already borrowed: BorrowMutError`。这也就是 `RefCell<T>` 如何在运行时处理违反借用规则的情况。

在运行时捕获借用错误而不是编译时意味着将会在开发过程的后期才会发现错误，甚至有可能发布到生产环境才发现；还会因为在运行时而不是编译时记录借用而导致少量的运行时性能惩罚。然而，使用 `RefCell` 使得在只允许不可变值的上下文中编写修改自身以记录消息的 mock 对象成为可能。虽然有取舍，但是我们可以选择使用 `RefCell<T>` 来获得比常规引用所能提供的更多的功能。

### [结合 `Rc` 和 `RefCell` 来拥有多个可变数据所有者](https://rust.bootcss.com/ch15-05-interior-mutability.html#结合-rct-和-refcellt-来拥有多个可变数据所有者)

`RefCell<T>` 的一个常见用法是与 `Rc<T>` 结合。回忆一下 `Rc<T>` 允许对相同数据有多个所有者，不过只能提供数据的不可变访问。如果有一个储存了 `RefCell<T>` 的 `Rc<T>` 的话，就可以得到有多个所有者 **并且** 可以修改的值了！

例如，回忆cons list 的例子中使用 `Rc<T>` 使得多个列表共享另一个列表的所有权。因为 `Rc<T>` 只存放不可变值，所以一旦创建了这些列表值后就不能修改。让我们加入 `RefCell<T>` 来获得修改列表中值的能力。以下示例展示了通过在 `Cons` 定义中使用 `RefCell<T>`，我们就允许修改所有列表中的值了：

文件名: src/main.rs

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
```

示例：使用 `Rc<RefCell<i32>>` 创建可以修改的 `List`

这里创建了一个 `Rc<RefCell<i32>>` 实例并储存在变量 `value` 中以便之后直接访问。接着在 `a` 中用包含 `value` 的 `Cons` 成员创建了一个 `List`。需要克隆 `value` 以便 `a` 和 `value` 都能拥有其内部值 `5` 的所有权，而不是将所有权从 `value` 移动到 `a` 或者让 `a` 借用 `value`。

我们将列表 `a` 封装进了 `Rc<T>` 这样当创建列表 `b` 和 `c` 时，他们都可以引用 `a`。

一旦创建了列表 `a`、`b` 和 `c`，我们将 `value` 的值加 10。为此对 `value` 调用了 `borrow_mut`，这里使用了自动解引用功能（[“`->` 运算符到哪去了？”](https://rust.bootcss.com/ch05-03-method-syntax.html#wheres-the---operator) 部分）来解引用 `Rc<T>` 以获取其内部的 `RefCell<T>` 值。`borrow_mut` 方法返回 `RefMut<T>` 智能指针，可以对其使用解引用运算符并修改其内部值。

当我们打印出 `a`、`b` 和 `c` 时，可以看到他们都拥有修改后的值 15 而不是 5：

```text
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
```

这是非常巧妙的！通过使用 `RefCell<T>`，我们可以拥有一个表面上不可变的 `List`，不过可以使用 `RefCell<T>` 中提供内部可变性的方法来在需要时修改数据。`RefCell<T>` 的运行时借用规则检查也确实保护我们免于出现数据竞争——有时为了数据结构的灵活性而付出一些性能是值得的。

标准库中也有其他提供内部可变性的类型，比如 `Cell<T>`，它有些类似 `RefCell<T>`，除了提供内部值的引用，其值还会被拷贝进和拷贝出 `Cell<T>`。还有 `Mutex<T>`，其提供线程间安全的内部可变性，我们将在第 16 章中讨论其用法。请查看标准库来获取更多细节和不同类型之间的区别。



# Arc && Mutex

​    通常情况下，当你在并发环境中共享数据时，要么使用***共享内存***，要么以***消息形式***传递数据。你可能经常听到传递消息（例如使用 Channel）是处理并发的首选方式，但我认为由于 Rust 中的所有权模型，二者在安全性或正确性上的区别并不像在其他语言中那么大。更具体地说：安全的 Rust 不允许有数据竞争。这也是为什么当我在 Rust 中选择消息传递或共享内存时，主要考虑的是便利性而非安全性。

​    如果你选择以共享内存的方式进行数据共享，你会发现，没有`Arc`和`Mutex`几乎寸步难行。<font color=#FF0000>`Arc`是一种智能指针，它能够让你在多线程之间安全地共享某个值。`Mutex`是另一种类型包装器（wrapper），它使得某个值可以在多线程之间被安全地修改。</font>为了完全理解这些概念，让我们先来了解 Rust 的所有权模型。

## **Rust 中的所有权（Ownership in Rust）**

如果你尝试对 Rust 中的所有模型进行提炼总结，可能会得到下面几条：

- 一个值只能有一个所有者
- 可以对一个值拥有多个**不可变**引用
- 对一个值只能有一个**可变**引用

​	让我们来看看这几条规则是如何工作的。给定一个`User`结构体，它包含一个字段`name`，类型为`String`。我们创建一个线程，并使用`user`打印一条消息。

```rust
use std::thread::spawn;

#[derive(Debug)]
struct User {
    name: String
}

fn main() {
    let user = User { name: "drogus".to_string() };

    spawn(move || {
        println!("Hello from the first thread {}", user.name);
    }).join().unwrap();
  	 
}
```

目前为止一切顺利，程序按照预期编译并输出信息。现在我们添加第二个线程（对应代码中的 t2），也去访问`user`实例。

```rust
1 fn main() {
2     let user = User { name: "drogus".to_string() };
3
4     let t1 = spawn(move || {
5         println!("Hello from the first thread {}", user.name);
6     });
7
8     let t2 = spawn(move || {
9         println!("Hello from the second thread {}", user.name);
10     });
11
12     t1.join().unwrap();
13     t2.join().unwrap();
14 }
```

​	编译这段代码会得到下面的错误信息。

```ps1con
error[E0382]: use of moved value: `user.name`
  --> src/main.rs:15:20
   |
11 |     let t1 = spawn(move || {
   |                    ------- value moved into closure here
12 |         println!("Hello from the first thread {}", user.name);
   |                                                    --------- variable moved due to use in closure
...
15 |     let t2 = spawn(move || {
   |                    ^^^^^^^ value used here after move
16 |         println!("Hello from the second thread {}", user.name);
   |                                                    --------- use occurs due to use in closure
   |
   = note: move occurs because `user.name` has type `String`, which does not implement the `Copy` trait
```

​	错误信息显示“use of moved value: `user.name`”。编译器也贴心地给我们指出问题出现的代码位置。在第 11 行（对应于上面代码第 4 行）代码中，我们把值移动到第一个线程中，接着在第 15 行（对应于上面代码第 8 行）代码，我们有尝试对第二个线程做同样的事情。如果你看过所有权规则，应该不难理解——**一个值只能有一个所有者**。在上面的代码中，如果我们想要使用`user.name`，就需要把它**移动（move）** 到第一个线程中，也因此我们就不能把它**移动（move）** 到另一个线程中。否则，就违背了所有权规则。

​	但是，我们没有对数据进行修改（mutate），这意味着我们可以对数据有多个（不可变）引用。让我们来试试。

```rust
fn main() {
    let user = User { name: "drogus".to_string() };

    let t1 = spawn(|| {
        println!("Hello from the first thread {}", &user.name);
    });

    let t2 = spawn(|| {
        println!("Hello from the second thread {}", &user.name);
    });

    t1.join().unwrap();
    t2.join().unwrap();
}
```

​	在这段代码上，我移除了闭包中的`move`关键字，并让线程不可变地**借用（borrow）** user，或者换句话说，我使用了一个由`&`表示的共享引用。编译这段代码会得到下面的信息。

```rust
error[E0373]: closure may outlive the current function, but it borrows `user.name`, which is owned by the current function
  --> src/main.rs:15:20
   |
15 |     let t2 = spawn(|| {
   |                    ^^ may outlive borrowed value `user.name`
16 |         println!("Hello from the first thread {}", &user.name);
   |                                                     --------- `user.name` is borrowed here
   |
note: function requires argument type to outlive `'static`
  --> src/main.rs:15:14
   |
15 |       let t2 = spawn(|| {
   |  ______________^
16 | |         println!("Hello from the second thread {}", &user.name);
17 | |     });
   | |______^
help: to force the closure to take ownership of `user.name` (and any other referenced variables), use the `move` keyword
   |
15 |     let t2 = spawn(move || {
   |                    ++++
```

​	现在，编译器报出的信息说，闭包可能比当前函数（main）的生存周期更长。换言之，也就是说 Rust 编译器无法保证线程中的闭包能够在 main 函数结束之前结束。`user`被线程借用，但是它被 main 函数所拥有。这种场景下，如果 main 函数结束，`user`就会离开作用域然后被销毁（Drop）。因此，如果按照上面的方式在线程间共享`user`，那么就可能会出现这种情况——线程尝试去读取已经被释放的内存。这是一种未定义行为并且我们也不希望出现这种情况。

​	编译器的提示信息还告诉我们，把变量`user`移动到线程中进而避免借用可能是有帮助的。不过这种情况我们在一开始就尝试了，并不太好。现在，有两种方式可以解决这个问题，其中之一便是`Arc`。不过，让我们先来了解另一种方式：scope thread。

## **Scoped threads**

​	Scoped threads 这一特性既可以通过**crossbeam**这个库获取，也可以通过 Rust 中的std::thread::scope(https://doc.rust-lang.org/nightly/std/thread/fn.scope.html)获取。本文使用了 crossbeam 提供的实现，但两种方式在使用上区别不大。在`Cargo.toml`中的依赖项中加入`crossbeam = "0.8"`，下面的代码就可以解决之前的问题。

```rust
use crossbeam::scope;

#[derive(Debug)]
struct User {
    name: String,
}

fn main() {
    let user = User {
        name: "drogus".to_string(),
    };

    scope(|s| {
        s.spawn(|_| {
            println!("Hello from the first thread {}", &user.name);
        });

        s.spawn(|_| {
            println!("Hello from the second thread {}", &user.name);
        });
    })
    .unwrap();
}
```

Scoped threads 的工作原理是，在某作用域内创建的所有线程都能被保证先于`scope`闭包结束。也就是说

- 在作用域闭包（scoped closure）离开作用域之前，线程被 join 并等待完成。得益于此，编译器知道没有任何借用会比所有者生存周期更长。

​	一个有趣的事情在这里值得注意，作为一个人类读者，我们会把这两个程序都解释为有效。在 Rust 拒绝的版本中，我们在`main()`函数结束之前就 join 了两个线程，所以将`user`与线程共享实际上是安全的。不幸的是，这是你在用 Rust 编写时可能遇到的情况。编写一个能接受所有有效程序的编译器是不可能的，因此我们只能退而求其次：编写一个能拒绝所有无效程序的编译器，但代价是过于严格。Scoped threads 是专门为了让我们以编译器可以接受的方式编写这种代码而加入的特性。

尽管 Scoped threads 有用，但并非所有的场合都适用，例如在编写异步（async）代码时，下面让我们来看看`Arc`。

## **Arc**

`Arc`是一种能够使得数据在线程间安全共享的智能指针，其名字是`Atomic Reference Counter`三个单词的首字母缩写。它的工作方式从本质上来讲，是对将要共享的数据进行包装，并表现为此数据的一个指针。`Arc`会追踪这个指针的所有拷贝，当最后一份拷贝离开作用域时，它就会安全释放内存。通过`Arc`解决之前问题的方案如下。

```rust
1 use std::thread::spawn;
2 use std::sync::Arc;
3
4 #[derive(Debug)]
5 struct User {
6     name: String
7 }
8
9 fn main() {
10     let user_original = Arc::new(User { name: "mochen".to_string() });
11
12    let user = user_original.clone();
13    let t1 = spawn(move || {
14        println!("Hello from the first thread {}", user.name);
15    });
16
17    let user = user_original.clone();
18    let t2 = spawn(move || {
19        println!("Hello from the first thread {}", user.name);
20    });
21
22    t1.join().unwrap();
23    t2.join().unwrap();
24}
```

首先，在第 10 行，我们创建了一个`user`并用一个`Arc`对它进行包装。现在，这个值存储在内存中并且`Arc`表现为它的一个指针。无论什么时候，我们对`Arc`进行克隆，都只是克隆了一份引用，而不是`user`本身。

在第 12 行和第 17 行，我们分别对`Arc`进行了克隆，并借着把克隆的指针移动到了新的线程中。如我们所见，`Arc`允许我们在不必考虑生命周期的情况下共享数据。在这个例子中，我们有三个指针指向`user`。一个是通过创建`Arc`得到，一个在开始第一个线程之前通过克隆得到并被移动到第一个线程中，还有一个是在开始第二个线程之前通过克隆得到并被移动到第二个线程中。只要这三个指针中的任何一个还在存活，Rust 就不会销毁`user`和释放内存。但是，当两个新线程和主函数结束时，所有的`Arc`指针都离开作用域，`user`也会随着最后一个指针离开作用域而被释放。

![image-20230911232742238](/Users/mochen/Library/Application Support/typora-user-images/image-20230911232742238.png)

## **Send and Sync**

如果你看过`Arc`的文档，你应该会看到它**实现了 Send 和 Sync**，但前提是被`Arc`包装的类型也实现了`Send`和`Sync`。为了理解这是什么意思以及它为何以这种方式实现，让我们从`Send`和`Sync`的定义开始看看。

**《The Rustonomicon》**对`Send`和`Sync`的定义如下：

- 如果一个类型能够被安全地发送到另一个线程，那么这个类型是`Send`；
- 如果一个类型能够安全地在线程间共享，那么这个类型是`Sync`。（当且仅当&T 是`Send`时，T 是`Sync`）

`Send`和`Sync`是作为一类标记 trait 存在，它们不提供任何需要被实现的方法，也不需要你去实现任何东西。它们的作用在于告知编译器某个类型在线程间可以被发送和共享的特性。让我们先从看起来相对直观的`Send`开始。它意味着你不能把一个`!Send`（读作：非`Send`）的类型发送到另一个线程。例如，你不能把它发送到 channel，也不能移动到一个线程里。以下面的代码为例，它就无法编译。

```rust
#![feature(negative_impls)]

#[derive(Debug)]
struct Foo {}
impl !Send for Foo {}

fn main() {
    let foo = Foo {};
    spawn(move || {
        dbg!(foo);
    });
}
```

`Send`和`Sync`是自动派生的，这意味着如果一个类型的所有字段都满足`Send`，那么这个类型也就自动实现了`Send`。这段代码使用了一个实验特性`negative_impls`，其作用在于让我们显式地告诉编译器，我想要把这个类型标记为`!Send`。尝试编译此代码将产生下面的错误：

```text
`Foo` cannot be sent between threads safely
```

如果你创建一个 channel 然后把`foo`发送至另一个线程，也会发生同样的事情。如果现在用上`Arc`会怎么样呢？你或许已经猜到，这没什么用，还是会以相同的方式报错（对于`!Sync`也是一样的，`Arc`需要同时满足这两个）。

```rust
#![feature(negative_impls)]

#[derive(Debug)]
struct Foo {}
impl !Send for Foo {}

fn main() {
    let foo = Arc::new(Foo {});
    spawn(move || {
        dbg!(foo);
    });
}
```

为什么会这样呢？`Arc`不是能够包装我们的类型并赋予它更多的能力么？确实如此，但`Arc`无法让我们的类型变成线程安全的。我会在文章末尾给出一个更深入的例子来解释原因，但是现在，我们先继续学习如何使用这些类型把。



## Arc的局限

​	Arc解决了多线程读取同一份数据的所有权争抢问题，例如下面的示例代码，没有使用Arc时，所有权发生转移，原来的持有者就失效了。  【待验证】

```rust
use std::thread;
use std::sync::{Arc, Mutex};
use std::time::Duration;

struct Hello {
    v: i32,
}

impl Hello {
    fn say_hello(&self) {
        println!("Hello, world! {}", self.v);
    }

    fn say_id(&self) {
        // println!("id = {:?}",thread::current().id());
        println!("id = {:?}, self = {:p}, self.v = {} ",thread::current().id(), self, self.v);
    }

    fn change(&mut self) {
        self.v += 10;
    }
}

// 直接传值，转移所有权
fn main() {
    let mut h = Hello{v:10};

    h.say_hello();
  
    thread::spawn(move || {
        h.say_hello();
        h.v = 20;     
        println!("h.v: {}", h.v);
    });

    h.v = 30;   
    println!("h.v: {}", h.v);
}
```

以上程序看似没有问题，但是会存在一些潜在的风险。尽管子线程结束后会将所有权返回给主线程，但在子线程结束之前，主线程可能会继续执行，因此在主线程中对`h`的后续修改可能会影响子线程中的值。

如果直接使用借用方式，将所有权一直保持在主线程中：

```rust
fn main() {
    let h = Hello{v:10};
    let r_h = &h;   

    thread::spawn(move || {
        r_h.say_hello();     // 引用指向的对象生命周期有可能不够长
    });

    h.say_hello();
    thread::sleep(Duration::from_secs(3));
}
```

则会编译报错：

```rust

error[E0597]: `h` does not live long enough
  --> src/main.rs:44:15
   |
43 |       let h = Hello{v:10};
   |           - binding `h` declared here
44 |       let r_h = &h;   
   |                 ^^ borrowed value does not live long enough
45 |
46 | /     thread::spawn(move || {
47 | |         r_h.say_hello();     // 引用指向的对象生命周期有可能不够长
48 | |     });
   | |______- argument requires that `h` is borrowed for `'static`
...
52 |   }
   |   - `h` dropped here while still borrowed

For more information about this error, try `rustc --explain E0597`.
warning: `demo` (bin "demo") generated 1 warning
```

因此，Arc就能派上用场。

```rust
fn main() {
    let h = Arc::new(Hello{v:10});
		
    thread::spawn(move || {
        h.say_hello();
    });

    thread::sleep(Duration::from_secs(1));
}
```

Arc也同样实现了引用计数，引用计数清为0时，arc指向的资源会被删除掉， 想想下一下代码的有什么问题？

```rust
fn main() {
    let h = Arc::new(Hello{v:10});

    thread::spawn(move || {
        h.say_hello();
    });
  
    h.say_hello();

    thread::sleep(Duration::from_secs(1));
}
```

如果想利用Arc实现多个线程的数据共享，需要通过clone()实现浅拷贝， 增加引用计数。

```rust
fn main() {
    let h = Arc::new(Hello{v:10});

    for _ in 0..10 {
        let h = h.clone();
        thread::spawn(move || {
            // h.say_hello();
            h.say_id();

        });

    }

    thread::sleep(Duration::from_secs(1));
}
```

这里我们只涉及到了数据的读取，如果需要修改呢？

```rust
fn main() {
    let h = Arc::new(Hello{v:10});

    for _ in 0..10 {
        let h = h.clone();
        thread::spawn(move || {
            h.change();
        });
    }

    thread::sleep(Duration::from_secs(1));
}
```

## **使用 Mutex 修改数据**

现在，我们开始讨论`Mutex`。`Mutex`在许多语言中都被视作（互斥）信号量（Semaphores）。你创建了一个 mutex 对象，通过每次只允许一个线程访问的方式，用它保护一段特定的代码段。在 Rust 中，`Mutex`更像是一个包装器（wrapper）。它让你在锁定 mutex 之后才能访问内部的值。`Mutex` 通常与 `Arc` 结合使用能够让线程间共享变量更加简单。让我们看看下面的示例：

```rust
1 use std::time::Duration;
2 use std::{thread, thread::sleep};
3 use std::sync::{Arc, Mutex};
4
5 struct User {
6     name: String
7 }
8
9 fn main() {
10     let user_original = Arc::new(Mutex::new(User { name: String::from("drogus") }));
11
12     let user = user_original.clone();
13     let t1 = thread::spawn(move || {
14         let mut locked_user = user.lock().unwrap();
15         locked_user.name = String::from("piotr");
16        // after locked_user goes out of scope, mutex will be unlocked again,
17         // but you can also explicitly unlock it with:
18         // drop(locked_user);
19     });
20
21     let user = user_original.clone();
22     let t2 = thread::spawn(move || {
23         sleep(Duration::from_millis(10));
24
25        // it will print: Hello piotr
26        println!("Hello {}", user.lock().unwrap().name);
27     });
28
29     t1.join().unwrap();
30     t2.join().unwrap();
31}
```

让我们看看这段代码。在 main()函数的第一行，我们创建了一个`User`结构体的实例并用`Mutex`和`Arc`对其进行包装。通过`Arc`，我们可以轻松克隆指针并在线程间共享`Mutex`。在第 14 行，你可以看到 mutex 被锁定并且在那之后底层的值可以被这个线程独占地使用。接着，我们在下一行代码对它的值进行修改。当离开作用域或我们手动调用`drop(locked_user)`时，mutex 被解除锁定。

在第二个线程中，我们等待 10ms 并打印出`name`。打印出的`name`应该是在第一个线程中被更新后的内容。这一次 lock 操作在同一行语句完成，所以在这条语句结束后，mutex 就会被解除锁定。

值得注意的是，我们在调用`lock()`后紧接着调用的`unwrap()`方法。标准库中的`Mutex`有一个被污染（poisoned）的概念。如果一个线程在 mutex 被锁定时 panic 了，我们无法确认`Mutex`中的值是否仍然有效，因此默认采取的行为是返回一个 error 而不是 guard。所以，`Mutex`要么返回一个装有值的`Ok()`变量或者一个 error。可以从文档获取更多的信息。一般而言，并不推荐在生产代码中使用`unwrap()`方法，但对于`Mutex`而言却是一个有效的方式——如果一个 `Mutex` 已经被污染了，我们可能判断出程序状态是无效的，并使程序崩溃。

另一个关于`Mutex` 有趣的事情是，只要 `Mutex` 中的类型是`Send`，`Mutex` 就会是`Sync`。这是因为`Mutex`确保只有一线程可以访问到内部的值，因此在线程间共享`Mutex` 是安全的。

## **Mutex: add Sync to a Send type**

可能你还记得文章开头说过，`Arc`需要底层的类型是`Send`+`Sync`，才能让`Arc`也是`Send`+`Sync`。`Mutex`只需要底层的类型是`Send`，就能够让 `Mutex` 是`Send`+`Sync`。换句话说，`Mutex` 将会使一个`!Sync`的类型`Sync`，因此，你可以在线程间共享和修改它。

## **Mutex without Arc?**

你可能会问，Mutex 是否可以不与`Arc`一起而单独使用。我建议你在继续阅读之前，自己先思考一下：对于一个`Send`类型的 Mutex 满足`Send`+`Sync`，这意味着什么？

如果你回到文章的第一部分，你可以看到它对 `Arc` 类型意味着什么，对于 `Mutex` 也意味着类似的事情。如果我们可以用类似 scope threads 的方式，完全可以脱离`Arc`单独使用`Mutex`：

```rust
use crossbeam::scope;
use std::{sync::Mutex, thread::sleep, time::Duration};

#[derive(Debug)]
struct User {
    name: String,
}

fn main() {
    let user = Mutex::new(User {
        name: "drogus".to_string(),
    });

    scope(|s| {
        s.spawn(|_| {
            user.lock().unwrap().name = String::from("piotr");
        });

        s.spawn(|_| {
            sleep(Duration::from_millis(10));

            // should print: Hello piotr
            println!("Hello {}", user.lock().unwrap().name);
        });
    })
    .unwrap();
}
```

在这段程序中，我们实现了相同的目标。我们正在两个独立线程中访问`Mutex`所包装的值，但是通过引用共享`Mutex`而没有使用`Arc`。但这并非总是可行的，比如在异步代码中，因此`Mutex`总是搭配`Arc`使用。

## **总结**

- 当你想在线程之间共享数据时，你通常会使用 Arc，而使用普通的引用是无法做到这一点的。
- 当你需要修改在线程间共享的数据时，你还需要使用`Mutex`。当你想要修改线程间共享的数据，并且无法通过使用引用来共享一个`Mutex`时，你应该使用`Arc<Mutex<...>>`。

## **Bonus: 为什么 Arc 需要类型是 Sync**

现在，让我们回到这样一个问题：为什么`Arc`需要底层的类型同时满足`Send`和`Sync`才能让自己是`Send`和`Sync`？这部分内容可以自由选择是否阅读，毕竟可能你的代码也不一定会用到`Arc`和`Mutex`。不过，它对于你理解标记 trait 可能有所帮助。

让我们以 `Cell` 为例。`Cell` 包装某个类型并使其具有内部可变性，或换句话说，它让我们可以在一个不可变的结构体上修改其内部的某个值。`Cell`是`Send`，但它也是`!Sync`。

使用 `Cell` 的例子如下：

```rust
use std::cell::Cell;

struct User {
    age: Cell<usize>
}

fn main() {
    let user = User { age: Cell::new(30) };

    user.age.set(36);

    // will print: Age: 36
    println!("Age: {}", user.age.get());
}
```

`Cell`在某些情况下是有用的，但它不是线程安全的，也就是说它是`!Sync`。如果你想在多个线程间共享一个由`Cell`包装的值，这可能会让两个线程修改同一处内存，例如：

```rust
// this example will not compile, `Cell` is `!Sync` and thus
// `Arc` will be `!Sync` and `!Send`
use std::cell::Cell;

struct User {
    age: Cell<usize>
}

fn main() {
    let user_original = Arc::new(User { age: Cell::new(30) });

    let user = user_original.clone();
    std::thread::spawn(move || {
        user.age.set(2);
    });

    let user = user_original.clone();
    std::thread::spawn(move || {
        user.age.set(3);
    });
}
```

如果这段代码运行，它可能会导致未定义行为。这就是为什么`Arc`无法与`!Send`或`!Sync`的类型一起工作。同时，`Cell`是 `Send`，这意味着它可以在线程间被发送。为什么？发送，或换个词-移动，不会让一个值被多个线程访问，它必须只能被一个线程拥有。一旦你把它移动到另一个线程，之前的线程就不再拥有这个值。基于这一点，我们总是在局部（local）修改一个 `Cell`。

## **Bonus: 为什么 Arc 需要类型**

到这里，你可能也会想，为什么`Arc`不会为一个`!Send` 类型提供`Send`特性。在 Rust 中，有一种类型是`!Send`，它就是`Rc`。Rc 是 Arc 的胞妹，但它不是原子的，Rc 仅用作引用计数器。它的作用与 Arc 基本相同，但只能在单线程中使用。它既不能在线程之间共享，也不能在线程之间移动。让我们来看看为什么

```rust
// this code won't compile, Rc is !Send and !Sync
use std::rc::Rc;

fn main() {
    let foo = Rc::new(1);

    let foo_clone = foo.clone();
    std::thread::spawn(move || {
        dbg!(foo_clone);
    });

    let foo_clone = foo.clone();
    std::thread::spawn(move || {
        dbg!(foo_clone);
    });
}
```

这段代码不会被编译，因为`Rc`是`!Sync`+`!Send`。它内部的计数器不是原子的，因此在线程间共享它会导致不准确的引用计数。现在假设`Arc`能够让`!Send`类型变成`Send`:

```rust
use std::rc::Rc;
use std::sync::Arc;

#[derive(Debug)]
struct User {
    name: Rc<String>,
}
unsafe impl Send for User {}
unsafe impl Sync for User {}

fn main() {
    let foo = Arc::new(User {
        name: Rc::new(String::from("drogus")),
    });

    let foo_clone = foo.clone();
    std::thread::spawn(move || {
        let name = foo_clone.name.clone();
    });

    let foo_clone = foo.clone();
    std::thread::spawn(move || {
        let name = foo_clone.name.clone();
    });
}
```

这段代码可以编译，但它是错误的，请不要在实际代码中这样写！在这里，我定义了一个`User`结构体，其内部有个`Rc`类型的成员。因为`Send`和`Sync`是自动派生的，并且 Rc 是`!Send`+`!Sync`，所以 User 结构体也应该是`!Send`+`!Sync`。但是我们可以显式地告诉编译器把它标记为其他，在这段代码中使用不安全的 impl 语法标记为了`Send`+`Sync`。

现在你可以清楚地看到，如果`Arc`允许`!Send`类型在线程间发送，会出什么问题了。在这个例子中，`Arc`的克隆被移动到不同的线程，然后没有任何东西阻止我们克隆 Rc 类型。并且因为 Rc 不是线程安全的，它可能会导致不准确的引用计数进而导致内存中的对象被过早释放或永不释放。

# weak<T>

在Rust中，`Weak<T>`是一个弱引用，它允许我们在不持有所有权的情况下引用一个`Rc<T>`指向的对象。与`Rc<T>`不同，`Weak<T>`不会增加引用计数，因此它不会阻止对象被释放。

`Weak<T>`通常用于解决引用循环的问题，比如当两个对象相互引用，导致它们的引用计数永远不会变为0，从而无法释放。通过使用`Weak<T>`，我们可以打破这种引用循环，避免内存泄漏。

下面是一个使用`Weak<T>`的简单示例：

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

struct Node {
    value: i32,
    next: Option<Weak<RefCell<Node>>>,
}

fn main() {
    let first = Rc::new(RefCell::new(Node {
        value: 1,
        next: None,
    }));

    let second = Rc::new(RefCell::new(Node {
        value: 2,
        next: Some(Rc::downgrade(&first)),
    }));

    // 更新第一个节点的next指针
    if let Some(ref weak_ref) = second.borrow().next {
        if let Some(ref strong_ref) = weak_ref.upgrade() {
            let mut first_borrow = first.borrow_mut();
            first_borrow.next = Some(Rc::downgrade(&strong_ref));
        }
    }

    // 打印节点的值
    println!("第一个节点的值: {}", first.borrow().value);
    let first1 = first.borrow();
    if let Some(ref weak_ref) = first1.next {
        if let Some(ref strong_ref) = weak_ref.upgrade() {
            println!("第二个节点的值: {}", strong_ref.borrow().value);
        }
    }
}
```

在这个示例中，我们创建了两个包含`Node`的`Rc<RefCell<Node>>`。在`Node`结构体中，我们使用`Option<Weak<RefCell<Node>>>`来表示下一个节点的弱引用。这允许我们在不持有所有权的情况下引用节点，并避免引用循环的问题。





陌琛：rust智能指针组合应用&，&mut，Rc, RefCell, Rc<RefCell>, Arc, Mutex, RwLock, Arc<Mutex>, Arc<RwLock> 参考文档：https://doc.rust-lang.org/book/





# Cow<'a,T>

参考文档： https://zhuanlan.zhihu.com/p/684402569#:~:text=%E8%AF%A6%E8%A7%A3Cow%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94%201%20%E4%BB%80%E4%B9%88%E6%98%AFCOW%EF%BC%88Copy-On-Write%EF%BC%89%EF%BC%9F%20%E5%9C%A8%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D%EF%BC%8C%E6%9C%89%E5%BF%85%E8%A6%81%E5%85%88%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BCOW%EF%BC%88Copy-On-Write%EF%BC%8C%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%82%20COW%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%EF%BC%8C%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%BA%94%E7%94%A8%E9%9D%9E%E5%B8%B8%E5%B9%BF%E6%B3%9B%E3%80%82%20COW%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E6%98%AF%E5%BD%93%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1%E9%9C%80%E8%A6%81%E8%AF%BB%E5%8F%96%E5%90%8C%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%EF%BC%88%E6%AF%94%E5%A6%82%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%81%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%BC%9A%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E4%BB%BD%E8%B5%84%E6%BA%90%E5%89%AF%E6%9C%AC%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%BA%E6%AF%8F%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%A4%8D%E5%88%B6%E4%B8%80%E4%BB%BD%E8%B5%84%E6%BA%90%E5%89%AF%E6%9C%AC%E3%80%82%20...%202,%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E8%8C%83%E4%BE%8B%EF%BC%9A%20...%204%20%E7%94%A8%E9%80%94%20%E8%AF%B4%E4%BA%86%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%8C%20Cow%20%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%91%A2%EF%BC%9F%20





